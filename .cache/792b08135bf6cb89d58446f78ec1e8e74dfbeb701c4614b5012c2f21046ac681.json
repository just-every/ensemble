{
  "url": "https://ai.google.dev/gemini-api/docs/live-guide",
  "markdown": "# Live API capabilities guide  |  Gemini API  |  Google AI for Developers\n[Skip to main content](#main-content)\n [![Google AI for Developers](https://www.gstatic.com/devrel-devsite/prod/v31bf0d5ece3babea9777b807f088a03e9bb2225d007f11b8410e9c896eb213a6/googledevai/images/lockup-new.svg)](https://ai.google.dev/)\n[Models](https://ai.google.dev/gemini-api/docs)\n-   Gemini\n-   [\n    About\n    ](https://deepmind.google/gemini)\n-   [\n    Docs\n    ](https://ai.google.dev/gemini-api/docs)\n-   [\n    API reference\n    ](https://ai.google.dev/api)\n-   [\n    Pricing\n    ](https://ai.google.dev/pricing)\n-   Imagen\n-   [\n    About\n    ](https://deepmind.google/technologies/imagen-3/)\n-   [\n    Docs\n    ](https://ai.google.dev/gemini-api/docs/image-generation#imagen)\n-   [\n    Pricing\n    ](https://ai.google.dev/pricing)\n-   Veo\n-   [\n    About\n    ](https://deepmind.google/technologies/veo/veo-2/)\n-   [\n    Docs\n    ](https://ai.google.dev/gemini-api/docs/video)\n-   [\n    Pricing\n    ](https://ai.google.dev/pricing)\n-   Gemma\n-   [\n    About\n    ](https://deepmind.google/models/gemma)\n-   [\n    Docs\n    ](https://ai.google.dev/gemma/docs)\n-   [\n    Gemmaverse\n    ](https://ai.google.dev/gemma/gemmaverse)\nSolutions\n-   Build with Gemini\n-   [\n    Gemini API\n    ](https://ai.google.dev/gemini-api/docs)\n-   [\n    Google AI Studio\n    ](https://aistudio.google.com)\n-   Customize Gemma open models\n-   [\n    Gemma open models\n    ](https://ai.google.dev/gemma)\n-   [\n    Multi-framework with Keras\n    ](https://keras.io/keras_3/)\n-   [\n    Fine-tune in Colab\n    ](https://colab.sandbox.google.com/github/google/generative-ai-docs/blob/main/site/en/gemma/docs/lora_tuning.ipynb)\n-   Run on-device\n-   [\n    Google AI Edge\n    ](https://ai.google.dev/edge)\n-   [\n    Gemini Nano on Android\n    ](https://developer.android.com/ai/gemini-nano)\n-   [\n    Chrome built-in web APIs\n    ](https://developer.chrome.com/docs/ai/built-in)\n-   Build responsibly\n-   [\n    Responsible GenAI Toolkit\n    ](https://ai.google.dev/responsible)\n-   [\n    Secure AI Framework\n    ](https://saif.google)\nCode assistance\n-   [\n    Android Studio\n    ](https://developer.android.com/gemini-in-android)\n-   [\n    Chrome DevTools\n    ](https://developer.chrome.com/docs/devtools/console/understand-messages)\n-   [\n    Colab\n    ](https://colab.google)\n-   [\n    Firebase\n    ](https://firebase.google.com/products/generative-ai)\n-   [\n    Google Cloud\n    ](https://cloud.google.com/products/gemini/code-assist)\n-   [\n    JetBrains\n    ](https://plugins.jetbrains.com/plugin/8079-google-cloud-code)\n-   [\n    Jules\n    ](https://labs.google.com/jules/home)\n-   [\n    VS Code\n    ](https://marketplace.visualstudio.com/items?itemName=GoogleCloudTools.cloudcode)\nShowcase\n-   [\n    Gemini Showcase\n    ](https://ai.google.dev/showcase)\n-   [\n    Gemini API Developer Competition\n    ](https://ai.google.dev/competition)\nCommunity\n-   [\n    Google AI Forum\n    ](https://discuss.ai.google.dev)\n-   [\n    Gemini for Research\n    ](https://ai.google.dev/gemini-api/docs/gemini-for-research)\n/\n-   English\n-   Deutsch\n-   Español – América Latina\n-   Français\n-   Indonesia\n-   Italiano\n-   Polski\n-   Português – Brasil\n-   Shqip\n-   Tiếng Việt\n-   Türkçe\n-   Русский\n-   עברית\n-   العربيّة\n-   فارسی\n-   हिंदी\n-   বাংলা\n-   ภาษาไทย\n-   中文 – 简体\n-   中文 – 繁體\n-   日本語\n-   한국어\nSign in\n[Gemini API docs](https://ai.google.dev/gemini-api/docs) [API Reference](https://ai.google.dev/api) [Cookbook](https://github.com/google-gemini/cookbook) [Community](https://discuss.ai.google.dev/c/gemini-api/) [![Google AI for Developers](https://www.gstatic.com/devrel-devsite/prod/v31bf0d5ece3babea9777b807f088a03e9bb2225d007f11b8410e9c896eb213a6/googledevai/images/lockup-new.svg)](https://ai.google.dev/)\n-   [Models](https://ai.google.dev/gemini-api/docs)\n    -   More\n    -   [Gemini API docs](https://ai.google.dev/gemini-api/docs)\n    -   [API Reference](https://ai.google.dev/api)\n    -   [Cookbook](https://github.com/google-gemini/cookbook)\n    -   [Community](https://discuss.ai.google.dev/c/gemini-api/)\n-   Solutions\n    -   More\n-   Code assistance\n    -   More\n-   Showcase\n    -   More\n-   Community\n    -   More\n-   Get started\n-   [Overview](https://ai.google.dev/gemini-api/docs)\n-   [Quickstart](https://ai.google.dev/gemini-api/docs/quickstart)\n-   [API keys](https://ai.google.dev/gemini-api/docs/api-key)\n-   [Libraries](https://ai.google.dev/gemini-api/docs/libraries)\n-   [OpenAI compatibility](https://ai.google.dev/gemini-api/docs/openai)\n-   Models\n-   [All models](https://ai.google.dev/gemini-api/docs/models)\n-   [Pricing](https://ai.google.dev/gemini-api/docs/pricing)\n-   [Rate limits](https://ai.google.dev/gemini-api/docs/rate-limits)\n-   [Billing info](https://ai.google.dev/gemini-api/docs/billing)\n-   Model Capabilities\n-   [Text generation](https://ai.google.dev/gemini-api/docs/text-generation)\n-   [Image generation](https://ai.google.dev/gemini-api/docs/image-generation)\n-   [Video generation](https://ai.google.dev/gemini-api/docs/video)\n-   [Speech generation](https://ai.google.dev/gemini-api/docs/speech-generation)\n-   [Music generation](https://ai.google.dev/gemini-api/docs/music-generation)\n-   [Long context](https://ai.google.dev/gemini-api/docs/long-context)\n-   [Structured output](https://ai.google.dev/gemini-api/docs/structured-output)\n-   [Thinking](https://ai.google.dev/gemini-api/docs/thinking)\n-   [Function calling](https://ai.google.dev/gemini-api/docs/function-calling)\n-   [Document understanding](https://ai.google.dev/gemini-api/docs/document-processing)\n-   [Image understanding](https://ai.google.dev/gemini-api/docs/image-understanding)\n-   [Video understanding](https://ai.google.dev/gemini-api/docs/video-understanding)\n-   [Audio understanding](https://ai.google.dev/gemini-api/docs/audio)\n-   [Code execution](https://ai.google.dev/gemini-api/docs/code-execution)\n-   [URL context](https://ai.google.dev/gemini-api/docs/url-context)\n-   [Google Search](https://ai.google.dev/gemini-api/docs/google-search)\n-   Guides\n-   [Prompt engineering](https://ai.google.dev/gemini-api/docs/prompting-strategies)\n-   Live API\n    -   [Get started](https://ai.google.dev/gemini-api/docs/live)\n    -   [Capabilities](https://ai.google.dev/gemini-api/docs/live-guide)\n    -   [Tool use](https://ai.google.dev/gemini-api/docs/live-tools)\n    -   [Session management](https://ai.google.dev/gemini-api/docs/live-session)\n    -   [Ephemeral tokens](https://ai.google.dev/gemini-api/docs/ephemeral-tokens)\n-   [Context caching](https://ai.google.dev/gemini-api/docs/caching)\n-   [Files API](https://ai.google.dev/gemini-api/docs/files)\n-   [Token counting](https://ai.google.dev/gemini-api/docs/tokens)\n-   Fine-tuning\n    -   [Intro to fine-tuning](https://ai.google.dev/gemini-api/docs/model-tuning)\n    -   [Fine-tuning tutorial](https://ai.google.dev/gemini-api/docs/model-tuning/tutorial)\n-   [Embeddings](https://ai.google.dev/gemini-api/docs/embeddings)\n-   Safety\n    -   [Safety settings](https://ai.google.dev/gemini-api/docs/safety-settings)\n    -   [Safety guidance](https://ai.google.dev/gemini-api/docs/safety-guidance)\n-   Resources\n-   [Migrate to Gen AI SDK](https://ai.google.dev/gemini-api/docs/migrate)\n-   [Release notes](https://ai.google.dev/gemini-api/docs/changelog)\n-   [API troubleshooting](https://ai.google.dev/gemini-api/docs/troubleshooting)\n-   Open-Source Frameworks\n    -   [LangChain & LangGraph](https://ai.google.dev/gemini-api/docs/langgraph-example)\n    -   [CrewAI](https://ai.google.dev/gemini-api/docs/crewai-example)\n-   AI Studio\n    -   [Google AI Studio quickstart](https://ai.google.dev/gemini-api/docs/ai-studio-quickstart)\n    -   [LearnLM](https://ai.google.dev/gemini-api/docs/learnlm)\n    -   [AI Studio troubleshooting](https://ai.google.dev/gemini-api/docs/troubleshoot-ai-studio)\n    -   [Google Workspace](https://ai.google.dev/gemini-api/docs/workspace)\n-   Google Cloud Platform\n    -   [VertexAI Gemini API](https://ai.google.dev/gemini-api/docs/migrate-to-cloud)\n    -   [OAuth authentication](https://ai.google.dev/gemini-api/docs/oauth)\n-   Policies\n-   [Terms of service](https://ai.google.dev/gemini-api/terms)\n-   [Available regions](https://ai.google.dev/gemini-api/docs/available-regions)\n-   [Additional usage polices](https://ai.google.dev/gemini-api/docs/usage-policies)\n-   Gemini\n-   [About](https://deepmind.google/gemini)\n-   [Docs](https://ai.google.dev/gemini-api/docs)\n-   [API reference](https://ai.google.dev/api)\n-   [Pricing](https://ai.google.dev/pricing)\n-   Imagen\n-   [About](https://deepmind.google/technologies/imagen-3/)\n-   [Docs](https://ai.google.dev/gemini-api/docs/image-generation#imagen)\n-   [Pricing](https://ai.google.dev/pricing)\n-   Veo\n-   [About](https://deepmind.google/technologies/veo/veo-2/)\n-   [Docs](https://ai.google.dev/gemini-api/docs/video)\n-   [Pricing](https://ai.google.dev/pricing)\n-   Gemma\n-   [About](https://deepmind.google/models/gemma)\n-   [Docs](https://ai.google.dev/gemma/docs)\n-   [Gemmaverse](https://ai.google.dev/gemma/gemmaverse)\n-   Build with Gemini\n-   [Gemini API](https://ai.google.dev/gemini-api/docs)\n-   [Google AI Studio](https://aistudio.google.com)\n-   Customize Gemma open models\n-   [Gemma open models](https://ai.google.dev/gemma)\n-   [Multi-framework with Keras](https://keras.io/keras_3/)\n-   [Fine-tune in Colab](https://colab.sandbox.google.com/github/google/generative-ai-docs/blob/main/site/en/gemma/docs/lora_tuning.ipynb)\n-   Run on-device\n-   [Google AI Edge](https://ai.google.dev/edge)\n-   [Gemini Nano on Android](https://developer.android.com/ai/gemini-nano)\n-   [Chrome built-in web APIs](https://developer.chrome.com/docs/ai/built-in)\n-   Build responsibly\n-   [Responsible GenAI Toolkit](https://ai.google.dev/responsible)\n-   [Secure AI Framework](https://saif.google)\n-   [Android Studio](https://developer.android.com/gemini-in-android)\n-   [Chrome DevTools](https://developer.chrome.com/docs/devtools/console/understand-messages)\n-   [Colab](https://colab.google)\n-   [Firebase](https://firebase.google.com/products/generative-ai)\n-   [Google Cloud](https://cloud.google.com/products/gemini/code-assist)\n-   [JetBrains](https://plugins.jetbrains.com/plugin/8079-google-cloud-code)\n-   [Jules](https://labs.google.com/jules/home)\n-   [VS Code](https://marketplace.visualstudio.com/items?itemName=GoogleCloudTools.cloudcode)\n-   [Gemini Showcase](https://ai.google.dev/showcase)\n-   [Gemini API Developer Competition](https://ai.google.dev/competition)\n-   [Google AI Forum](https://discuss.ai.google.dev)\n-   [Gemini for Research](https://ai.google.dev/gemini-api/docs/gemini-for-research)\nIntroducing updates to our 2.5 family of thinking models. [Learn more](https://ai.google.dev/gemini-api/docs/models)\n-   [Home](https://ai.google.dev/)\n-   [Gemini API](https://ai.google.dev/gemini-api)\n-   [Models](https://ai.google.dev/gemini-api/docs)\nSend feedback\n# Live API capabilities guide\n**Preview:** The Live API is in preview.\nThis is a comprehensive guide that covers capabilities and configurations available with the Live API. See [Get started with Live API](https://ai.google.dev/gemini-api/docs/live) page for a overview and sample code for common use cases.\n## Before you begin\n-   **Familiarize yourself with core concepts:** If you haven't already done so, read the [Get started with Live API](https://ai.google.dev/gemini-api/doc/live) page first. This will introduce you to the fundamental principles of the Live API, how it works, and the distinction between the [different models](https://ai.google.dev/gemini-api/doc/live#models) and their corresponding audio generation methods ([native audio](#native-audio-output) or half-cascade).\n-   **Try the Live API in AI Studio:** You may find it useful to try the Live API in [Google AI Studio](https://aistudio.google.com/app/live) before you start building. To use the Live API in Google AI Studio, select **Stream**.\n## Establishing a connection\nThe following example shows how to create a connection with an API key:\n### Python\n```\nimport asyncio\nfrom google import genai\nclient = genai.Client(api_key=\"GEMINI_API_KEY\")\nmodel = \"gemini-2.0-flash-live-001\"\nconfig = {\"response_modalities\": [\"TEXT\"]}\nasync def main():\n    async with client.aio.live.connect(model=model, config=config) as session:\n        print(\"Session started\")\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n### JavaScript\n```\nimport { GoogleGenAI, Modality } from '@google/genai';\nconst ai = new GoogleGenAI({ apiKey: \"GOOGLE_API_KEY\" });\nconst model = 'gemini-2.0-flash-live-001';\nconst config = { responseModalities: [Modality.TEXT] };\nasync function main() {\n  const session = await ai.live.connect({\n    model: model,\n    callbacks: {\n      onopen: function () {\n        console.debug('Opened');\n      },\n      onmessage: function (message) {\n        console.debug(message);\n      },\n      onerror: function (e) {\n        console.debug('Error:', e.message);\n      },\n      onclose: function (e) {\n        console.debug('Close:', e.reason);\n      },\n    },\n    config: config,\n  });\n  // Send content...\n  session.close();\n}\nmain();\n```\n**Note:** You can only set [one modality](https://ai.google.dev/gemini-api/docs/live#response-modalities) in the `response_modalities` field. This means that you can configure the model to respond with either text or audio, but not both in the same session.\n## Interaction modalities\nThe following sections provide examples and supporting context for the different input and output modalities available in Live API.\n### Sending and receiving text\nHere's how you can send and receive text:\n### Python\n```\nimport asyncio\nfrom google import genai\nclient = genai.Client(api_key=\"GEMINI_API_KEY\")\nmodel = \"gemini-2.0-flash-live-001\"\nconfig = {\"response_modalities\": [\"TEXT\"]}\nasync def main():\n    async with client.aio.live.connect(model=model, config=config) as session:\n        message = \"Hello, how are you?\"\n        await session.send_client_content(\n            turns={\"role\": \"user\", \"parts\": [{\"text\": message}]}, turn_complete=True\n        )\n        async for response in session.receive():\n            if response.text is not None:\n                print(response.text, end=\"\")\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n### JavaScript\n```\nimport { GoogleGenAI, Modality } from '@google/genai';\nconst ai = new GoogleGenAI({ apiKey: \"GOOGLE_API_KEY\" });\nconst model = 'gemini-2.0-flash-live-001';\nconst config = { responseModalities: [Modality.TEXT] };\nasync function live() {\n  const responseQueue = [];\n  async function waitMessage() {\n    let done = false;\n    let message = undefined;\n    while (!done) {\n      message = responseQueue.shift();\n      if (message) {\n        done = true;\n      } else {\n        await new Promise((resolve) => setTimeout(resolve, 100));\n      }\n    }\n    return message;\n  }\n  async function handleTurn() {\n    const turns = [];\n    let done = false;\n    while (!done) {\n      const message = await waitMessage();\n      turns.push(message);\n      if (message.serverContent && message.serverContent.turnComplete) {\n        done = true;\n      }\n    }\n    return turns;\n  }\n  const session = await ai.live.connect({\n    model: model,\n    callbacks: {\n      onopen: function () {\n        console.debug('Opened');\n      },\n      onmessage: function (message) {\n        responseQueue.push(message);\n      },\n      onerror: function (e) {\n        console.debug('Error:', e.message);\n      },\n      onclose: function (e) {\n        console.debug('Close:', e.reason);\n      },\n    },\n    config: config,\n  });\n  const inputTurns = 'Hello how are you?';\n  session.sendClientContent({ turns: inputTurns });\n  const turns = await handleTurn();\n  for (const turn of turns) {\n    if (turn.text) {\n      console.debug('Received text: %s\\n', turn.text);\n    }\n    else if (turn.data) {\n      console.debug('Received inline data: %s\\n', turn.data);\n    }\n  }\n  session.close();\n}\nasync function main() {\n  await live().catch((e) => console.error('got error', e));\n}\nmain();\n```\n#### Incremental content updates\nUse incremental updates to send text input, establish session context, or restore session context. For short contexts you can send turn-by-turn interactions to represent the exact sequence of events:\n### Python\n```\nturns = [\n    {\"role\": \"user\", \"parts\": [{\"text\": \"What is the capital of France?\"}]},\n    {\"role\": \"model\", \"parts\": [{\"text\": \"Paris\"}]},\n]\nawait session.send_client_content(turns=turns, turn_complete=False)\nturns = [{\"role\": \"user\", \"parts\": [{\"text\": \"What is the capital of Germany?\"}]}]\nawait session.send_client_content(turns=turns, turn_complete=True)\n```\n### JavaScript\n```\nlet inputTurns = [\n  { \"role\": \"user\", \"parts\": [{ \"text\": \"What is the capital of France?\" }] },\n  { \"role\": \"model\", \"parts\": [{ \"text\": \"Paris\" }] },\n]\nsession.sendClientContent({ turns: inputTurns, turnComplete: false })\ninputTurns = [{ \"role\": \"user\", \"parts\": [{ \"text\": \"What is the capital of Germany?\" }] }]\nsession.sendClientContent({ turns: inputTurns, turnComplete: true })\n```\nFor longer contexts it's recommended to provide a single message summary to free up the context window for subsequent interactions. See [Session Resumption](https://ai.google.dev/gemini-api/docs/live-session#session-resumption) for another method for loading session context.\n### Sending and receiving audio\nThe most common audio example, **audio-to-audio**, is covered in the [Getting started](https://ai.google.dev/gemini-api/docs/live#audio-to-audio) guide.\nHere's an **audio-to-text** example that reads a WAV file, sends it in the correct format and receives text output:\n### Python\n```\n# Test file: https://storage.googleapis.com/generativeai-downloads/data/16000.wav\n# Install helpers for converting files: pip install librosa soundfile\nimport asyncio\nimport io\nfrom pathlib import Path\nfrom google import genai\nfrom google.genai import types\nimport soundfile as sf\nimport librosa\nclient = genai.Client(api_key=\"GEMINI_API_KEY\")\nmodel = \"gemini-2.0-flash-live-001\"\nconfig = {\"response_modalities\": [\"TEXT\"]}\nasync def main():\n    async with client.aio.live.connect(model=model, config=config) as session:\n        buffer = io.BytesIO()\n        y, sr = librosa.load(\"sample.wav\", sr=16000)\n        sf.write(buffer, y, sr, format='RAW', subtype='PCM_16')\n        buffer.seek(0)\n        audio_bytes = buffer.read()\n        # If already in correct format, you can use this:\n        # audio_bytes = Path(\"sample.pcm\").read_bytes()\n        await session.send_realtime_input(\n            audio=types.Blob(data=audio_bytes, mime_type=\"audio/pcm;rate=16000\")\n        )\n        async for response in session.receive():\n            if response.text is not None:\n                print(response.text)\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n### JavaScript\n```\n// Test file: https://storage.googleapis.com/generativeai-downloads/data/16000.wav\n// Install helpers for converting files: npm install wavefile\nimport { GoogleGenAI, Modality } from '@google/genai';\nimport * as fs from \"node:fs\";\nimport pkg from 'wavefile';\nconst { WaveFile } = pkg;\nconst ai = new GoogleGenAI({ apiKey: \"GOOGLE_API_KEY\" });\nconst model = 'gemini-2.0-flash-live-001';\nconst config = { responseModalities: [Modality.TEXT] };\nasync function live() {\n  const responseQueue = [];\n  async function waitMessage() {\n    let done = false;\n    let message = undefined;\n    while (!done) {\n      message = responseQueue.shift();\n      if (message) {\n        done = true;\n      } else {\n        await new Promise((resolve) => setTimeout(resolve, 100));\n      }\n    }\n    return message;\n  }\n  async function handleTurn() {\n    const turns = [];\n    let done = false;\n    while (!done) {\n      const message = await waitMessage();\n      turns.push(message);\n      if (message.serverContent && message.serverContent.turnComplete) {\n        done = true;\n      }\n    }\n    return turns;\n  }\n  const session = await ai.live.connect({\n    model: model,\n    callbacks: {\n      onopen: function () {\n        console.debug('Opened');\n      },\n      onmessage: function (message) {\n        responseQueue.push(message);\n      },\n      onerror: function (e) {\n        console.debug('Error:', e.message);\n      },\n      onclose: function (e) {\n        console.debug('Close:', e.reason);\n      },\n    },\n    config: config,\n  });\n  // Send Audio Chunk\n  const fileBuffer = fs.readFileSync(\"sample.wav\");\n  // Ensure audio conforms to API requirements (16-bit PCM, 16kHz, mono)\n  const wav = new WaveFile();\n  wav.fromBuffer(fileBuffer);\n  wav.toSampleRate(16000);\n  wav.toBitDepth(\"16\");\n  const base64Audio = wav.toBase64();\n  // If already in correct format, you can use this:\n  // const fileBuffer = fs.readFileSync(\"sample.pcm\");\n  // const base64Audio = Buffer.from(fileBuffer).toString('base64');\n  session.sendRealtimeInput(\n    {\n      audio: {\n        data: base64Audio,\n        mimeType: \"audio/pcm;rate=16000\"\n      }\n    }\n  );\n  const turns = await handleTurn();\n  for (const turn of turns) {\n    if (turn.text) {\n      console.debug('Received text: %s\\n', turn.text);\n    }\n    else if (turn.data) {\n      console.debug('Received inline data: %s\\n', turn.data);\n    }\n  }\n  session.close();\n}\nasync function main() {\n  await live().catch((e) => console.error('got error', e));\n}\nmain();\n```\nAnd here is a **text-to-audio** example. You can receive audio by setting `AUDIO` as response modality. This example saves the received data as WAV file:\n### Python\n```\nimport asyncio\nimport wave\nfrom google import genai\nclient = genai.Client(api_key=\"GEMINI_API_KEY\")\nmodel = \"gemini-2.0-flash-live-001\"\nconfig = {\"response_modalities\": [\"AUDIO\"]}\nasync def main():\n    async with client.aio.live.connect(model=model, config=config) as session:\n        wf = wave.open(\"audio.wav\", \"wb\")\n        wf.setnchannels(1)\n        wf.setsampwidth(2)\n        wf.setframerate(24000)\n        message = \"Hello how are you?\"\n        await session.send_client_content(\n            turns={\"role\": \"user\", \"parts\": [{\"text\": message}]}, turn_complete=True\n        )\n        async for response in session.receive():\n            if response.data is not None:\n                wf.writeframes(response.data)\n            # Un-comment this code to print audio data info\n            # if response.server_content.model_turn is not None:\n            #      print(response.server_content.model_turn.parts[0].inline_data.mime_type)\n        wf.close()\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n### JavaScript\n```\nimport { GoogleGenAI, Modality } from '@google/genai';\nimport * as fs from \"node:fs\";\nimport pkg from 'wavefile';\nconst { WaveFile } = pkg;\nconst ai = new GoogleGenAI({ apiKey: \"GOOGLE_API_KEY\" });\nconst model = 'gemini-2.0-flash-live-001';\nconst config = { responseModalities: [Modality.AUDIO] };\nasync function live() {\n  const responseQueue = [];\n  async function waitMessage() {\n    let done = false;\n    let message = undefined;\n    while (!done) {\n      message = responseQueue.shift();\n      if (message) {\n        done = true;\n      } else {\n        await new Promise((resolve) => setTimeout(resolve, 100));\n      }\n    }\n    return message;\n  }\n  async function handleTurn() {\n    const turns = [];\n    let done = false;\n    while (!done) {\n      const message = await waitMessage();\n      turns.push(message);\n      if (message.serverContent && message.serverContent.turnComplete) {\n        done = true;\n      }\n    }\n    return turns;\n  }\n  const session = await ai.live.connect({\n    model: model,\n    callbacks: {\n      onopen: function () {\n        console.debug('Opened');\n      },\n      onmessage: function (message) {\n        responseQueue.push(message);\n      },\n      onerror: function (e) {\n        console.debug('Error:', e.message);\n      },\n      onclose: function (e) {\n        console.debug('Close:', e.reason);\n      },\n    },\n    config: config,\n  });\n  const inputTurns = 'Hello how are you?';\n  session.sendClientContent({ turns: inputTurns });\n  const turns = await handleTurn();\n  // Combine audio data strings and save as wave file\n  const combinedAudio = turns.reduce((acc, turn) => {\n    if (turn.data) {\n      const buffer = Buffer.from(turn.data, 'base64');\n      const intArray = new Int16Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / Int16Array.BYTES_PER_ELEMENT);\n      return acc.concat(Array.from(intArray));\n    }\n    return acc;\n  }, []);\n  const audioBuffer = new Int16Array(combinedAudio);\n  const wf = new WaveFile();\n  wf.fromScratch(1, 24000, '16', audioBuffer);\n  fs.writeFileSync('output.wav', wf.toBuffer());\n  session.close();\n}\nasync function main() {\n  await live().catch((e) => console.error('got error', e));\n}\nmain();\n```\n#### Audio formats\nAudio data in the Live API is always raw, little-endian, 16-bit PCM. Audio output always uses a sample rate of 24kHz. Input audio is natively 16kHz, but the Live API will resample if needed so any sample rate can be sent. To convey the sample rate of input audio, set the MIME type of each audio-containing [Blob](https://ai.google.dev/api/caching#Blob) to a value like `audio/pcm;rate=16000`.\n#### Audio transcriptions\nYou can enable transcription of the model's audio output by sending `output_audio_transcription` in the setup config. The transcription language is inferred from the model's response.\n### Python\n```\nimport asyncio\nfrom google import genai\nfrom google.genai import types\nclient = genai.Client(api_key=\"GEMINI_API_KEY\")\nmodel = \"gemini-2.0-flash-live-001\"\nconfig = {\"response_modalities\": [\"AUDIO\"],\n        \"output_audio_transcription\": {}\n}\nasync def main():\n    async with client.aio.live.connect(model=model, config=config) as session:\n        message = \"Hello? Gemini are you there?\"\n        await session.send_client_content(\n            turns={\"role\": \"user\", \"parts\": [{\"text\": message}]}, turn_complete=True\n        )\n        async for response in session.receive():\n            if response.server_content.model_turn:\n                print(\"Model turn:\", response.server_content.model_turn)\n            if response.server_content.output_transcription:\n                print(\"Transcript:\", response.server_content.output_transcription.text)\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n### JavaScript\n```\nimport { GoogleGenAI, Modality } from '@google/genai';\nconst ai = new GoogleGenAI({ apiKey: \"GOOGLE_API_KEY\" });\nconst model = 'gemini-2.0-flash-live-001';\nconst config = {\n  responseModalities: [Modality.AUDIO],\n  outputAudioTranscription: {}\n};\nasync function live() {\n  const responseQueue = [];\n  async function waitMessage() {\n    let done = false;\n    let message = undefined;\n    while (!done) {\n      message = responseQueue.shift();\n      if (message) {\n        done = true;\n      } else {\n        await new Promise((resolve) => setTimeout(resolve, 100));\n      }\n    }\n    return message;\n  }\n  async function handleTurn() {\n    const turns = [];\n    let done = false;\n    while (!done) {\n      const message = await waitMessage();\n      turns.push(message);\n      if (message.serverContent && message.serverContent.turnComplete) {\n        done = true;\n      }\n    }\n    return turns;\n  }\n  const session = await ai.live.connect({\n    model: model,\n    callbacks: {\n      onopen: function () {\n        console.debug('Opened');\n      },\n      onmessage: function (message) {\n        responseQueue.push(message);\n      },\n      onerror: function (e) {\n        console.debug('Error:', e.message);\n      },\n      onclose: function (e) {\n        console.debug('Close:', e.reason);\n      },\n    },\n    config: config,\n  });\n  const inputTurns = 'Hello how are you?';\n  session.sendClientContent({ turns: inputTurns });\n  const turns = await handleTurn();\n  for (const turn of turns) {\n    if (turn.serverContent && turn.serverContent.outputTranscription) {\n      console.debug('Received output transcription: %s\\n', turn.serverContent.outputTranscription.text);\n    }\n  }\n  session.close();\n}\nasync function main() {\n  await live().catch((e) => console.error('got error', e));\n}\nmain();\n```\nYou can enable transcription of the audio input by sending `input_audio_transcription` in setup config.\n### Python\n```\nimport asyncio\nfrom pathlib import Path\nfrom google import genai\nfrom google.genai import types\nclient = genai.Client(api_key=\"GEMINI_API_KEY\")\nmodel = \"gemini-2.0-flash-live-001\"\nconfig = {\n    \"response_modalities\": [\"TEXT\"],\n    \"input_audio_transcription\": {},\n}\nasync def main():\n    async with client.aio.live.connect(model=model, config=config) as session:\n        audio_data = Path(\"16000.pcm\").read_bytes()\n        await session.send_realtime_input(\n            audio=types.Blob(data=audio_data, mime_type='audio/pcm;rate=16000')\n        )\n        async for msg in session.receive():\n            if msg.server_content.input_transcription:\n                print('Transcript:', msg.server_content.input_transcription.text)\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n### JavaScript\n```\nimport { GoogleGenAI, Modality } from '@google/genai';\nimport * as fs from \"node:fs\";\nimport pkg from 'wavefile';\nconst { WaveFile } = pkg;\nconst ai = new GoogleGenAI({ apiKey: \"GOOGLE_API_KEY\" });\nconst model = 'gemini-2.0-flash-live-001';\nconst config = {\n  responseModalities: [Modality.TEXT],\n  inputAudioTranscription: {}\n};\nasync function live() {\n  const responseQueue = [];\n  async function waitMessage() {\n    let done = false;\n    let message = undefined;\n    while (!done) {\n      message = responseQueue.shift();\n      if (message) {\n        done = true;\n      } else {\n        await new Promise((resolve) => setTimeout(resolve, 100));\n      }\n    }\n    return message;\n  }\n  async function handleTurn() {\n    const turns = [];\n    let done = false;\n    while (!done) {\n      const message = await waitMessage();\n      turns.push(message);\n      if (message.serverContent && message.serverContent.turnComplete) {\n        done = true;\n      }\n    }\n    return turns;\n  }\n  const session = await ai.live.connect({\n    model: model,\n    callbacks: {\n      onopen: function () {\n        console.debug('Opened');\n      },\n      onmessage: function (message) {\n        responseQueue.push(message);\n      },\n      onerror: function (e) {\n        console.debug('Error:', e.message);\n      },\n      onclose: function (e) {\n        console.debug('Close:', e.reason);\n      },\n    },\n    config: config,\n  });\n  // Send Audio Chunk\n  const fileBuffer = fs.readFileSync(\"16000.wav\");\n  // Ensure audio conforms to API requirements (16-bit PCM, 16kHz, mono)\n  const wav = new WaveFile();\n  wav.fromBuffer(fileBuffer);\n  wav.toSampleRate(16000);\n  wav.toBitDepth(\"16\");\n  const base64Audio = wav.toBase64();\n  // If already in correct format, you can use this:\n  // const fileBuffer = fs.readFileSync(\"sample.pcm\");\n  // const base64Audio = Buffer.from(fileBuffer).toString('base64');\n  session.sendRealtimeInput(\n    {\n      audio: {\n        data: base64Audio,\n        mimeType: \"audio/pcm;rate=16000\"\n      }\n    }\n  );\n  const turns = await handleTurn();\n  for (const turn of turns) {\n    if (turn.serverContent && turn.serverContent.outputTranscription) {\n      console.log(\"Transcription\")\n      console.log(turn.serverContent.outputTranscription.text);\n    }\n  }\n  for (const turn of turns) {\n    if (turn.text) {\n      console.debug('Received text: %s\\n', turn.text);\n    }\n    else if (turn.data) {\n      console.debug('Received inline data: %s\\n', turn.data);\n    }\n    else if (turn.serverContent && turn.serverContent.inputTranscription) {\n      console.debug('Received input transcription: %s\\n', turn.serverContent.inputTranscription.text);\n    }\n  }\n  session.close();\n}\nasync function main() {\n  await live().catch((e) => console.error('got error', e));\n}\nmain();\n```\n### Stream audio and video\nTo see an example of how to use the Live API in a streaming audio and video format, run the \"Live API - Get Started\" file in the cookbooks repository:\n[View on GitHub](https://github.com/google-gemini/cookbook/blob/main/quickstarts/Get_started_LiveAPI.py)\n### Change voice and language\nThe Live API models each support a different set of voices. Half-cascade supports Puck, Charon, Kore, Fenrir, Aoede, Leda, Orus, and Zephyr. Native audio supports a much longer list (identical to [the TTS model list](https://ai.google.dev/gemini-api/docs/speech-generation#voices)). You can listen to all the voices in [AI Studio](https://aistudio.google.com/app/live).\nTo specify a voice, set the voice name within the `speechConfig` object as part of the session configuration:\n### Python\n```\nconfig = {\n    \"response_modalities\": [\"AUDIO\"],\n    \"speech_config\": {\n        \"voice_config\": {\"prebuilt_voice_config\": {\"voice_name\": \"Kore\"}}\n    },\n}\n```\n### JavaScript\n```\nconst config = {\n  responseModalities: [Modality.AUDIO],\n  speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: \"Kore\" } } }\n};\n```\n**Note:** If you're using the `generateContent` API, the set of available voices is slightly different. See the [audio generation guide](https://ai.google.dev/gemini-api/docs/audio-generation#voices) for `generateContent` audio generation voices.\nThe Live API supports [multiple languages](#supported-languages).\nTo change the language, set the language code within the `speechConfig` object as part of the session configuration:\n### Python\n```\nconfig = {\n    \"response_modalities\": [\"AUDIO\"],\n    \"speech_config\": {\n        \"language_code\": \"de-DE\"\n    }\n}\n```\n### JavaScript\n```\nconst config = {\n  responseModalities: [Modality.AUDIO],\n  speechConfig: { languageCode: \"de-DE\" }\n};\n```\n**Note:** [Native audio output](#native-audio-output) models automatically choose the appropriate language and don't support explicitly setting the language code.\n## Native audio capabilities\nThe following capabilities are only available with native audio. You can learn more about native audio in [Choose a model and audio generation](https://ai.google.dev/gemini-api/docs/api).\n**Note:** Native audio models currently have limited tool use support. See [Overview of supported tools](https://ai.google.dev/gemini-api/docs/live-tools#tools-overview) for details.\n### How to use native audio output\nTo use native audio output, configure one of the [native audio models](https://ai.google.dev/gemini-api/docs/models#gemini-2.5-flash-native-audio) and set `response_modalities` to `AUDIO`.\nSee [Send and receive audio](https://ai.google.dev/gemini-api/docs/live#audio-to-audio) for a full example.\n### Python\n```\nmodel = \"gemini-2.5-flash-preview-native-audio-dialog\"\nconfig = types.LiveConnectConfig(response_modalities=[\"AUDIO\"])\nasync with client.aio.live.connect(model=model, config=config) as session:\n    # Send audio input and receive audio\n```\n### JavaScript\n```\nconst model = 'gemini-2.5-flash-preview-native-audio-dialog';\nconst config = { responseModalities: [Modality.AUDIO] };\nasync function main() {\n  const session = await ai.live.connect({\n    model: model,\n    config: config,\n    callbacks: ...,\n  });\n  // Send audio input and receive audio\n  session.close();\n}\nmain();\n```\n### Affective dialog\nThis feature lets Gemini adapt its response style to the input expression and tone.\nTo use affective dialog, set the api version to `v1alpha` and set `enable_affective_dialog` to `true`in the setup message:\n### Python\n```\nclient = genai.Client(api_key=\"GOOGLE_API_KEY\", http_options={\"api_version\": \"v1alpha\"})\nconfig = types.LiveConnectConfig(\n    response_modalities=[\"AUDIO\"],\n    enable_affective_dialog=True\n)\n```\n### JavaScript\n```\nconst ai = new GoogleGenAI({ apiKey: \"GOOGLE_API_KEY\", httpOptions: {\"apiVersion\": \"v1alpha\"} });\nconst config = {\n  responseModalities: [Modality.AUDIO],\n  enableAffectiveDialog: true\n};\n```\nNote that affective dialog is currently only supported by the native audio output models.\n### Proactive audio\nWhen this feature is enabled, Gemini can proactively decide not to respond if the content is not relevant.\nTo use it, set the api version to `v1alpha` and configure the `proactivity` field in the setup message and set `proactive_audio` to `true`:\n### Python\n```\nclient = genai.Client(api_key=\"GOOGLE_API_KEY\", http_options={\"api_version\": \"v1alpha\"})\nconfig = types.LiveConnectConfig(\n    response_modalities=[\"AUDIO\"],\n    proactivity={'proactive_audio': True}\n)\n```\n### JavaScript\n```\nconst ai = new GoogleGenAI({ apiKey: \"GOOGLE_API_KEY\", httpOptions: {\"apiVersion\": \"v1alpha\"} });\nconst config = {\n  responseModalities: [Modality.AUDIO],\n  proactivity: { proactiveAudio: true }\n}\n```\nNote that proactive audio is currently only supported by the native audio output models.\n### Native audio output with thinking\nNative audio output supports [thinking capabilities](https://ai.google.dev/gemini-api/docs/thinking), available via a separate model `gemini-2.5-flash-exp-native-audio-thinking-dialog`.\nSee [Send and receive audio](https://ai.google.dev/gemini-api/docs/live#audio-to-audio) for a full example.\n### Python\n```\nmodel = \"gemini-2.5-flash-exp-native-audio-thinking-dialog\"\nconfig = types.LiveConnectConfig(response_modalities=[\"AUDIO\"])\nasync with client.aio.live.connect(model=model, config=config) as session:\n    # Send audio input and receive audio\n```\n### JavaScript\n```\nconst model = 'gemini-2.5-flash-exp-native-audio-thinking-dialog';\nconst config = { responseModalities: [Modality.AUDIO] };\nasync function main() {\n  const session = await ai.live.connect({\n    model: model,\n    config: config,\n    callbacks: ...,\n  });\n  // Send audio input and receive audio\n  session.close();\n}\nmain();\n```\n## Voice Activity Detection (VAD)\nVoice Activity Detection (VAD) allows the model to recognize when a person is speaking. This is essential for creating natural conversations, as it allows a user to interrupt the model at any time.\nWhen VAD detects an interruption, the ongoing generation is canceled and discarded. Only the information already sent to the client is retained in the session history. The server then sends a [`BidiGenerateContentServerContent`](https://ai.google.dev/api/live#bidigeneratecontentservercontent) message to report the interruption.\nThe Gemini server then discards any pending function calls and sends a `BidiGenerateContentServerContent` message with the IDs of the canceled calls.\n### Python\n```\nasync for response in session.receive():\n    if response.server_content.interrupted is True:\n        # The generation was interrupted\n        # If realtime playback is implemented in your application,\n        # you should stop playing audio and clear queued playback here.\n```\n### JavaScript\n```\nconst turns = await handleTurn();\nfor (const turn of turns) {\n  if (turn.serverContent && turn.serverContent.interrupted) {\n    // The generation was interrupted\n    // If realtime playback is implemented in your application,\n    // you should stop playing audio and clear queued playback here.\n  }\n}\n```\n### Automatic VAD\nBy default, the model automatically performs VAD on a continuous audio input stream. VAD can be configured with the [`realtimeInputConfig.automaticActivityDetection`](https://ai.google.dev/api/live#RealtimeInputConfig.AutomaticActivityDetection) field of the [setup configuration](https://ai.google.dev/api/live#BidiGenerateContentSetup).\nWhen the audio stream is paused for more than a second (for example, because the user switched off the microphone), an [`audioStreamEnd`](https://ai.google.dev/api/live#BidiGenerateContentRealtimeInput.FIELDS.bool.BidiGenerateContentRealtimeInput.audio_stream_end) event should be sent to flush any cached audio. The client can resume sending audio data at any time.\n### Python\n```\n# example audio file to try:\n# URL = \"https://storage.googleapis.com/generativeai-downloads/data/hello_are_you_there.pcm\"\n# !wget -q $URL -O sample.pcm\nimport asyncio\nfrom pathlib import Path\nfrom google import genai\nfrom google.genai import types\nclient = genai.Client(api_key=\"GEMINI_API_KEY\")\nmodel = \"gemini-2.0-flash-live-001\"\nconfig = {\"response_modalities\": [\"TEXT\"]}\nasync def main():\n    async with client.aio.live.connect(model=model, config=config) as session:\n        audio_bytes = Path(\"sample.pcm\").read_bytes()\n        await session.send_realtime_input(\n            audio=types.Blob(data=audio_bytes, mime_type=\"audio/pcm;rate=16000\")\n        )\n        # if stream gets paused, send:\n        # await session.send_realtime_input(audio_stream_end=True)\n        async for response in session.receive():\n            if response.text is not None:\n                print(response.text)\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n### JavaScript\n```\n// example audio file to try:\n// URL = \"https://storage.googleapis.com/generativeai-downloads/data/hello_are_you_there.pcm\"\n// !wget -q $URL -O sample.pcm\nimport { GoogleGenAI, Modality } from '@google/genai';\nimport * as fs from \"node:fs\";\nconst ai = new GoogleGenAI({ apiKey: \"GOOGLE_API_KEY\" });\nconst model = 'gemini-2.0-flash-live-001';\nconst config = { responseModalities: [Modality.TEXT] };\nasync function live() {\n  const responseQueue = [];\n  async function waitMessage() {\n    let done = false;\n    let message = undefined;\n    while (!done) {\n      message = responseQueue.shift();\n      if (message) {\n        done = true;\n      } else {\n        await new Promise((resolve) => setTimeout(resolve, 100));\n      }\n    }\n    return message;\n  }\n  async function handleTurn() {\n    const turns = [];\n    let done = false;\n    while (!done) {\n      const message = await waitMessage();\n      turns.push(message);\n      if (message.serverContent && message.serverContent.turnComplete) {\n        done = true;\n      }\n    }\n    return turns;\n  }\n  const session = await ai.live.connect({\n    model: model,\n    callbacks: {\n      onopen: function () {\n        console.debug('Opened');\n      },\n      onmessage: function (message) {\n        responseQueue.push(message);\n      },\n      onerror: function (e) {\n        console.debug('Error:', e.message);\n      },\n      onclose: function (e) {\n        console.debug('Close:', e.reason);\n      },\n    },\n    config: config,\n  });\n  // Send Audio Chunk\n  const fileBuffer = fs.readFileSync(\"sample.pcm\");\n  const base64Audio = Buffer.from(fileBuffer).toString('base64');\n  session.sendRealtimeInput(\n    {\n      audio: {\n        data: base64Audio,\n        mimeType: \"audio/pcm;rate=16000\"\n      }\n    }\n  );\n  // if stream gets paused, send:\n  // session.sendRealtimeInput({ audioStreamEnd: true })\n  const turns = await handleTurn();\n  for (const turn of turns) {\n    if (turn.text) {\n      console.debug('Received text: %s\\n', turn.text);\n    }\n    else if (turn.data) {\n      console.debug('Received inline data: %s\\n', turn.data);\n    }\n  }\n  session.close();\n}\nasync function main() {\n  await live().catch((e) => console.error('got error', e));\n}\nmain();\n```\nWith `send_realtime_input`, the API will respond to audio automatically based on VAD. While `send_client_content` adds messages to the model context in order, `send_realtime_input` is optimized for responsiveness at the expense of deterministic ordering.\n### Automatic VAD configuration\nFor more control over the VAD activity, you can configure the following parameters. See [API reference](https://ai.google.dev/api/live#automaticactivitydetection) for more info.\n### Python\n```\nfrom google.genai import types\nconfig = {\n    \"response_modalities\": [\"TEXT\"],\n    \"realtime_input_config\": {\n        \"automatic_activity_detection\": {\n            \"disabled\": False, # default\n            \"start_of_speech_sensitivity\": types.StartSensitivity.START_SENSITIVITY_LOW,\n            \"end_of_speech_sensitivity\": types.EndSensitivity.END_SENSITIVITY_LOW,\n            \"prefix_padding_ms\": 20,\n            \"silence_duration_ms\": 100,\n        }\n    }\n}\n```\n### JavaScript\n```\nimport { GoogleGenAI, Modality, StartSensitivity, EndSensitivity } from '@google/genai';\nconst config = {\n  responseModalities: [Modality.TEXT],\n  realtimeInputConfig: {\n    automaticActivityDetection: {\n      disabled: false, // default\n      startOfSpeechSensitivity: StartSensitivity.START_SENSITIVITY_LOW,\n      endOfSpeechSensitivity: EndSensitivity.END_SENSITIVITY_LOW,\n      prefixPaddingMs: 20,\n      silenceDurationMs: 100,\n    }\n  }\n};\n```\n### Disable automatic VAD\nAlternatively, the automatic VAD can be disabled by setting `realtimeInputConfig.automaticActivityDetection.disabled` to `true` in the setup message. In this configuration the client is responsible for detecting user speech and sending [`activityStart`](https://ai.google.dev/api/live#BidiGenerateContentRealtimeInput.FIELDS.BidiGenerateContentRealtimeInput.ActivityStart.BidiGenerateContentRealtimeInput.activity_start) and [`activityEnd`](https://ai.google.dev/api/live#BidiGenerateContentRealtimeInput.FIELDS.BidiGenerateContentRealtimeInput.ActivityEnd.BidiGenerateContentRealtimeInput.activity_end) messages at the appropriate times. An `audioStreamEnd` isn't sent in this configuration. Instead, any interruption of the stream is marked by an `activityEnd` message.\n### Python\n```\nconfig = {\n    \"response_modalities\": [\"TEXT\"],\n    \"realtime_input_config\": {\"automatic_activity_detection\": {\"disabled\": True}},\n}\nasync with client.aio.live.connect(model=model, config=config) as session:\n    # ...\n    await session.send_realtime_input(activity_start=types.ActivityStart())\n    await session.send_realtime_input(\n        audio=types.Blob(data=audio_bytes, mime_type=\"audio/pcm;rate=16000\")\n    )\n    await session.send_realtime_input(activity_end=types.ActivityEnd())\n    # ...\n```\n### JavaScript\n```\nconst config = {\n  responseModalities: [Modality.TEXT],\n  realtimeInputConfig: {\n    automaticActivityDetection: {\n      disabled: true,\n    }\n  }\n};\nsession.sendRealtimeInput({ activityStart: {} })\nsession.sendRealtimeInput(\n  {\n    audio: {\n      data: base64Audio,\n      mimeType: \"audio/pcm;rate=16000\"\n    }\n  }\n);\nsession.sendRealtimeInput({ activityEnd: {} })\n```\n## Token count\nYou can find the total number of consumed tokens in the [usageMetadata](https://ai.google.dev/api/live#usagemetadata) field of the returned server message.\n### Python\n```\nasync for message in session.receive():\n    # The server will periodically send messages that include UsageMetadata.\n    if message.usage_metadata:\n        usage = message.usage_metadata\n        print(\n            f\"Used {usage.total_token_count} tokens in total. Response token breakdown:\"\n        )\n        for detail in usage.response_tokens_details:\n            match detail:\n                case types.ModalityTokenCount(modality=modality, token_count=count):\n                    print(f\"{modality}: {count}\")\n```\n### JavaScript\n```\nconst turns = await handleTurn();\nfor (const turn of turns) {\n  if (turn.usageMetadata) {\n    console.debug('Used %s tokens in total. Response token breakdown:\\n', turn.usageMetadata.totalTokenCount);\n    for (const detail of turn.usageMetadata.responseTokensDetails) {\n      console.debug('%s\\n', detail);\n    }\n  }\n}\n```\n## Media resolution\nYou can specify the media resolution for the input media by setting the `mediaResolution` field as part of the session configuration:\n### Python\n```\nfrom google.genai import types\nconfig = {\n    \"response_modalities\": [\"AUDIO\"],\n    \"media_resolution\": types.MediaResolution.MEDIA_RESOLUTION_LOW,\n}\n```\n### JavaScript\n```\nimport { GoogleGenAI, Modality, MediaResolution } from '@google/genai';\nconst config = {\n    responseModalities: [Modality.TEXT],\n    mediaResolution: MediaResolution.MEDIA_RESOLUTION_LOW,\n};\n```\n## Limitations\nConsider the following limitations of the Live API when you plan your project.\n### Response modalities\nYou can only set one response modality (`TEXT` or `AUDIO`) per session in the session configuration. Setting both results in a config error message. This means that you can configure the model to respond with either text or audio, but not both in the same session.\n### Client authentication\nThe Live API only provides server-to-server authentication by default. If you're implementing your Live API application using a [client-to-server approach](https://ai.google.dev/gemini-api/docs/live#implementation-approach), you need to use [ephemeral tokens](https://ai.google.dev/gemini-api/docs/ephemeral-tokens) to mitigate security risks.\n### Session duration\nAudio-only sessions are limited to 15 minutes, and audio plus video sessions are limited to 2 minutes. However, you can configure different [session management techniques](https://ai.google.dev/gemini-api/docs/live-session) for unlimited extensions on session duration.\n### Context window\nA session has a context window limit of:\n-   128k tokens for [native audio output](#native-audio-output) models\n-   32k tokens for other Live API models\n## Supported languages\nLive API supports the following languages.\n**Note:** [Native audio output](#native-audio-output) models automatically choose the appropriate language and don't support explicitly setting the language code.\n| Language | BCP-47 Code | Language | BCP-47 Code |\n| --- | --- | --- | --- |\n| German (Germany) | `de-DE` | English (Australia)\\* | `en-AU` |\n| English (UK)\\* | `en-GB` | English (India) | `en-IN` |\n| English (US) | `en-US` | Spanish (US) | `es-US` |\n| French (France) | `fr-FR` | Hindi (India) | `hi-IN` |\n| Portuguese (Brazil) | `pt-BR` | Arabic (Generic) | `ar-XA` |\n| Spanish (Spain)\\* | `es-ES` | French (Canada)\\* | `fr-CA` |\n| Indonesian (Indonesia) | `id-ID` | Italian (Italy) | `it-IT` |\n| Japanese (Japan) | `ja-JP` | Turkish (Turkey) | `tr-TR` |\n| Vietnamese (Vietnam) | `vi-VN` | Bengali (India) | `bn-IN` |\n| Gujarati (India)\\* | `gu-IN` | Kannada (India)\\* | `kn-IN` |\n| Marathi (India) | `mr-IN` | Malayalam (India)\\* | `ml-IN` |\n| Tamil (India) | `ta-IN` | Telugu (India) | `te-IN` |\n| Dutch (Netherlands) | `nl-NL` | Korean (South Korea) | `ko-KR` |\n| Mandarin Chinese (China)\\* | `cmn-CN` | Polish (Poland) | `pl-PL` |\n| Russian (Russia) | `ru-RU` | Thai (Thailand) | `th-TH` |\n_Languages marked with an asterisk_ (\\*) _are not available for [Native audio](#native-audio-output)_.\n## What's next\n-   Read the [Tool Use](https://ai.google.dev/gemini-api/docs/live-tools) and [Session Management](https://ai.google.dev/gemini-api/docs/live-session) guides for essential information on using the Live API effectively.\n-   Try the Live API in [Google AI Studio](https://aistudio.google.com/app/live).\n-   For more info about the Live API models, see [Gemini 2.0 Flash Live](https://ai.google.dev/gemini-api/docs/models#live-api) and [Gemini 2.5 Flash Native Audio](https://ai.google.dev/gemini-api/docs/models#gemini-2.5-flash-native-audio) on the Models page.\n-   Try more examples in the [Live API cookbook](https://github.com/google-gemini/cookbook/blob/main/quickstarts/Get_started_LiveAPI.ipynb), the [Live API Tools cookbook](https://github.com/google-gemini/cookbook/blob/main/quickstarts/Get_started_LiveAPI_tools.ipynb), and the [Live API Get Started script](https://github.com/google-gemini/cookbook/blob/main/quickstarts/Get_started_LiveAPI.py).\nSend feedback\nExcept as otherwise noted, the content of this page is licensed under the [Creative Commons Attribution 4.0 License](https://creativecommons.org/licenses/by/4.0/), and code samples are licensed under the [Apache 2.0 License](https://www.apache.org/licenses/LICENSE-2.0). For details, see the [Google Developers Site Policies](https://developers.google.com/site-policies). Java is a registered trademark of Oracle and/or its affiliates.\nLast updated 2025-06-17 UTC.\n-   [Terms](//policies.google.com/terms)\n-   [Privacy](//policies.google.com/privacy)\n-   [Manage cookies](#)\n-   English\n-   Deutsch\n-   Español – América Latina\n-   Français\n-   Indonesia\n-   Italiano\n-   Polski\n-   Português – Brasil\n-   Shqip\n-   Tiếng Việt\n-   Türkçe\n-   Русский\n-   עברית\n-   العربيّة\n-   فارسی\n-   हिंदी\n-   বাংলা\n-   ภาษาไทย\n-   中文 – 简体\n-   中文 – 繁體\n-   日本語\n-   한국어",
  "timestamp": 1750330350980,
  "title": "Live API capabilities guide  |  Gemini API  |  Google AI for Developers"
}