<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Live Transcription</title>
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            border-radius: 12px;
            padding: 32px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        h1 {
            color: #1a73e8;
            margin-top: 0;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .status-card {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 20px;
            align-items: center;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 24px;
        }
        .status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 18px;
            font-weight: 500;
        }
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e0e0e0;
            transition: all 0.3s;
        }
        .status.connected .status-indicator {
            background: #34a853;
            animation: pulse 2s infinite;
        }
        .status.connecting .status-indicator {
            background: #fbbc04;
        }
        .status.error .status-indicator {
            background: #ea4335;
        }
        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.1); }
            100% { opacity: 1; transform: scale(1); }
        }
        .controls {
            display: flex;
            gap: 12px;
        }
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .start-btn {
            background: #1a73e8;
            color: white;
        }
        .start-btn:hover:not(:disabled) {
            background: #1557b0;
            transform: translateY(-1px);
        }
        .stop-btn {
            background: #ea4335;
            color: white;
        }
        .stop-btn:hover:not(:disabled) {
            background: #d33b2c;
            transform: translateY(-1px);
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }
        .metric {
            padding: 16px;
            background: #f8f9fa;
            border-radius: 8px;
            text-align: center;
        }
        .metric-label {
            font-size: 12px;
            color: #5f6368;
            text-transform: uppercase;
            margin-bottom: 4px;
        }
        .metric-value {
            font-size: 24px;
            font-weight: 600;
            color: #202124;
        }
        .transcript-section {
            margin-top: 32px;
        }
        .transcript-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        .transcript-box {
            background: #f8f9fa;
            border: 1px solid #e8eaed;
            border-radius: 8px;
            padding: 20px;
            min-height: 200px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 14px;
            line-height: 1.6;
        }
        .transcript-item {
            margin-bottom: 12px;
            padding: 12px;
            background: white;
            border-radius: 6px;
            border-left: 3px solid #1a73e8;
            animation: slideIn 0.3s ease-out;
        }
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        .transcript-item.partial {
            opacity: 0.7;
            border-left-color: #fbbc04;
            font-style: italic;
        }
        .timestamp {
            font-size: 11px;
            color: #5f6368;
            margin-bottom: 4px;
        }
        .audio-visualizer {
            width: 100%;
            height: 80px;
            background: #202124;
            border-radius: 8px;
            margin-bottom: 24px;
            position: relative;
            overflow: hidden;
        }
        .visualizer-bar {
            position: absolute;
            bottom: 0;
            width: 2px;
            background: #1a73e8;
            transition: height 0.1s;
        }
        .info-box {
            background: #e8f0fe;
            border: 1px solid #c5d9f7;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 24px;
            display: flex;
            align-items: start;
            gap: 12px;
        }
        .info-icon {
            color: #1a73e8;
            font-size: 20px;
        }
        .clear-btn {
            background: #f8f9fa;
            color: #5f6368;
            border: 1px solid #dadce0;
            padding: 8px 16px;
            font-size: 14px;
        }
        .clear-btn:hover:not(:disabled) {
            background: #f1f3f4;
            border-color: #d2d3d5;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>
            <span style="font-size: 32px;">üéôÔ∏è</span>
            Gemini Live Transcription
        </h1>
        
        <div class="info-box">
            <div class="info-icon">‚ÑπÔ∏è</div>
            <div>
                <strong>Real-time Cost Tracking:</strong> The Gemini Live API provides token usage data for accurate cost calculation. Costs are calculated based on actual input/output tokens at the current Gemini pricing rates.
            </div>
        </div>
        
        <div class="status-card">
            <div class="status" id="status">
                <div class="status-indicator"></div>
                <span id="statusText">Ready to connect</span>
            </div>
            <div class="controls">
                <button id="startBtn" class="start-btn">
                    <span>‚ñ∂Ô∏è</span> Start Transcription
                </button>
                <button id="stopBtn" class="stop-btn" style="display: none;">
                    <span>‚èπÔ∏è</span> Stop
                </button>
            </div>
        </div>
        
        <div class="metrics">
            <div class="metric">
                <div class="metric-label">Duration</div>
                <div class="metric-value" id="duration">0:00</div>
            </div>
            <div class="metric">
                <div class="metric-label">Audio Sent</div>
                <div class="metric-value" id="audioData">0 KB</div>
            </div>
            <div class="metric">
                <div class="metric-label">Words</div>
                <div class="metric-value" id="wordCount">0</div>
            </div>
            <div class="metric">
                <div class="metric-label">Cost</div>
                <div class="metric-value" id="cost">$0.0000</div>
            </div>
            <div class="metric">
                <div class="metric-label">Tokens</div>
                <div class="metric-value" id="tokens">0</div>
            </div>
        </div>
        
        <canvas id="visualizer" class="audio-visualizer"></canvas>
        
        <div class="transcript-section">
            <div class="transcript-header">
                <h2>Transcript</h2>
                <button id="clearBtn" class="clear-btn">Clear</button>
            </div>
            <div id="transcript" class="transcript-box">
                <div style="color: #9aa0a6; text-align: center; padding: 40px;">
                    Click "Start Transcription" to begin...
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Gemini 2.5 Flash Live API pricing per 1K tokens (as of January 2025)
        const GEMINI_PRICING = {
            'gemini-live-2.5-flash-preview': {
                // Text tokens
                inputText: 0.0005,    // $0.50 per 1M input text tokens = $0.0005 per 1K
                outputText: 0.002,    // $2.00 per 1M output text tokens = $0.002 per 1K
                // Audio tokens
                inputAudio: 0.003,    // $3.00 per 1M input audio tokens = $0.003 per 1K
                outputAudio: 0.012,   // $12.00 per 1M output audio tokens = $0.012 per 1K
                // Video tokens (not used in this app)
                inputVideo: 0.003,    // $3.00 per 1M input video tokens = $0.003 per 1K
            }
        };
        
        class GeminiLiveClient {
            constructor() {
                this.ws = null;
                this.audioContext = null;
                this.mediaStream = null;
                this.processor = null;
                this.analyser = null;
                this.isStreaming = false;
                
                // Stats
                this.startTime = null;
                this.audioBytes = 0;
                this.wordCount = 0;
                this.totalTokens = 0;
                this.totalCost = 0;
                this.tokenUsage = {
                    input: 0,
                    output: 0,
                    inputText: 0,
                    inputAudio: 0,
                    outputText: 0,
                    outputAudio: 0
                };
                
                // UI elements
                this.statusEl = document.getElementById('status');
                this.statusTextEl = document.getElementById('statusText');
                this.startBtn = document.getElementById('startBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.transcriptEl = document.getElementById('transcript');
                this.durationEl = document.getElementById('duration');
                this.audioDataEl = document.getElementById('audioData');
                this.wordCountEl = document.getElementById('wordCount');
                this.costEl = document.getElementById('cost');
                this.tokensEl = document.getElementById('tokens');
                this.clearBtn = document.getElementById('clearBtn');
                this.canvas = document.getElementById('visualizer');
                this.canvasCtx = this.canvas.getContext('2d');
                
                // Set canvas size
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = this.canvas.offsetHeight;
                
                // Bind events
                this.startBtn.addEventListener('click', () => this.start());
                this.stopBtn.addEventListener('click', () => this.stop());
                this.clearBtn.addEventListener('click', () => this.clearTranscript());
                
                // Update stats
                setInterval(() => this.updateStats(), 100);
                
                // Audio buffer for smooth streaming
                this.audioQueue = [];
                this.sendInterval = null;
                
                // Visualizer
                this.initVisualizer();
            }
            
            initVisualizer() {
                const barCount = Math.floor(this.canvas.width / 4);
                this.visualizerBars = [];
                
                for (let i = 0; i < barCount; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'visualizer-bar';
                    bar.style.left = `${i * 4}px`;
                    this.canvas.appendChild(bar);
                    this.visualizerBars.push(bar);
                }
            }
            
            async start() {
                try {
                    this.setStatus('connecting', 'Connecting...');
                    this.transcriptEl.innerHTML = '';
                    this.resetStats();
                    
                    // Get microphone with optimal settings for Gemini (16kHz)
                    this.mediaStream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            sampleRate: 16000,
                            channelCount: 1,
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        } 
                    });
                    
                    // Setup audio context
                    this.audioContext = new AudioContext({ sampleRate: 48000 });
                    const source = this.audioContext.createMediaStreamSource(this.mediaStream);
                    
                    // Create analyser for visualization
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 256;
                    this.analyser.smoothingTimeConstant = 0.8;
                    
                    // Create script processor
                    this.processor = this.audioContext.createScriptProcessor(2048, 1, 1);
                    
                    // Connect WebSocket
                    this.ws = new WebSocket('ws://localhost:3002/gemini-live');
                    this.ws.binaryType = 'arraybuffer';
                    
                    this.ws.onopen = () => {
                        this.setStatus('connected', 'Connected - Speak now!');
                        this.isStreaming = true;
                        this.startTime = Date.now();
                        this.startBtn.style.display = 'none';
                        this.stopBtn.style.display = 'block';
                        
                        // Start sending audio chunks every 100ms for low latency
                        this.sendInterval = setInterval(() => this.sendAudioChunk(), 100);
                    };
                    
                    this.ws.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        
                        if (data.type === 'transcript') {
                            this.addTranscript(data.text, data.partial);
                            if (!data.partial) {
                                this.wordCount += data.text.split(/\s+/).filter(w => w.length > 0).length;
                            }
                        } else if (data.type === 'usage') {
                            // Update token usage and cost
                            this.updateTokenUsage(data.usage);
                        } else if (data.type === 'error') {
                            this.setStatus('error', 'Error: ' + data.message);
                            console.error('Stream error:', data);
                        } else if (data.type === 'status') {
                            console.log('Status:', data.message);
                        }
                    };
                    
                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.setStatus('error', 'Connection error');
                        this.stop();
                    };
                    
                    this.ws.onclose = () => {
                        this.setStatus('idle', 'Disconnected');
                        this.stop();
                    };
                    
                    // Process audio
                    this.processor.onaudioprocess = (e) => {
                        if (!this.isStreaming) return;
                        
                        const inputData = e.inputBuffer.getChannelData(0);
                        
                        // Downsample from 48kHz to 16kHz
                        const downsampledData = this.downsample(inputData, 48000, 16000);
                        
                        // Convert to PCM16
                        const pcm16 = this.convertToPCM16(downsampledData);
                        
                        // Add to queue
                        this.audioQueue.push(pcm16);
                        this.audioBytes += pcm16.byteLength;
                    };
                    
                    // Connect audio nodes
                    source.connect(this.analyser);
                    source.connect(this.processor);
                    this.processor.connect(this.audioContext.destination);
                    
                    // Start visualizer
                    this.visualize();
                    
                } catch (error) {
                    console.error('Start error:', error);
                    this.setStatus('error', 'Error: ' + error.message);
                    this.stop();
                }
            }
            
            sendAudioChunk() {
                if (!this.ws || this.ws.readyState !== WebSocket.OPEN || this.audioQueue.length === 0) {
                    return;
                }
                
                // Combine queued audio chunks
                const totalLength = this.audioQueue.reduce((sum, chunk) => sum + chunk.byteLength, 0);
                const combined = new ArrayBuffer(totalLength);
                const view = new Uint8Array(combined);
                
                let offset = 0;
                for (const chunk of this.audioQueue) {
                    view.set(new Uint8Array(chunk), offset);
                    offset += chunk.byteLength;
                }
                
                // Clear queue
                this.audioQueue = [];
                
                // Send combined chunk
                this.ws.send(combined);
            }
            
            stop() {
                this.isStreaming = false;
                
                if (this.sendInterval) {
                    clearInterval(this.sendInterval);
                    this.sendInterval = null;
                }
                
                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
                
                if (this.processor) {
                    this.processor.disconnect();
                    this.processor = null;
                }
                
                if (this.analyser) {
                    this.analyser.disconnect();
                    this.analyser = null;
                }
                
                if (this.audioContext) {
                    this.audioContext.close();
                    this.audioContext = null;
                }
                
                if (this.mediaStream) {
                    this.mediaStream.getTracks().forEach(track => track.stop());
                    this.mediaStream = null;
                }
                
                this.startBtn.style.display = 'block';
                this.stopBtn.style.display = 'none';
                this.setStatus('idle', 'Ready to connect');
                
                // Reset visualizer
                this.visualizerBars.forEach(bar => bar.style.height = '0');
            }
            
            setStatus(type, message) {
                this.statusTextEl.textContent = message;
                this.statusEl.className = `status ${type}`;
            }
            
            addTranscript(text, isPartial = false) {
                const timestamp = new Date().toLocaleTimeString();
                
                if (isPartial) {
                    // Update or add partial transcript
                    let partialEl = this.transcriptEl.querySelector('.partial');
                    if (!partialEl) {
                        partialEl = document.createElement('div');
                        partialEl.className = 'transcript-item partial';
                        this.transcriptEl.appendChild(partialEl);
                    }
                    partialEl.innerHTML = `
                        <div class="timestamp">${timestamp}</div>
                        <div>${text}</div>
                    `;
                } else {
                    // Remove partial and add final transcript
                    const partialEl = this.transcriptEl.querySelector('.partial');
                    if (partialEl) {
                        partialEl.remove();
                    }
                    
                    const item = document.createElement('div');
                    item.className = 'transcript-item';
                    item.innerHTML = `
                        <div class="timestamp">${timestamp}</div>
                        <div>${text}</div>
                    `;
                    this.transcriptEl.appendChild(item);
                    
                    // Auto-scroll
                    this.transcriptEl.scrollTop = this.transcriptEl.scrollHeight;
                }
            }
            
            clearTranscript() {
                this.transcriptEl.innerHTML = '';
                this.wordCount = 0;
                this.wordCountEl.textContent = '0';
            }
            
            visualize() {
                if (!this.analyser) return;
                
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                const draw = () => {
                    if (!this.isStreaming) return;
                    
                    requestAnimationFrame(draw);
                    
                    this.analyser.getByteFrequencyData(dataArray);
                    
                    const barWidth = this.visualizerBars.length;
                    const step = Math.floor(bufferLength / barWidth);
                    
                    for (let i = 0; i < barWidth; i++) {
                        const value = dataArray[i * step];
                        const height = (value / 255) * this.canvas.height;
                        this.visualizerBars[i].style.height = `${height}px`;
                    }
                };
                
                draw();
            }
            
            downsample(buffer, fromSampleRate, toSampleRate) {
                const sampleRateRatio = fromSampleRate / toSampleRate;
                const newLength = Math.round(buffer.length / sampleRateRatio);
                const result = new Float32Array(newLength);
                
                let offsetResult = 0;
                let offsetBuffer = 0;
                
                while (offsetResult < result.length) {
                    const nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);
                    let accum = 0;
                    let count = 0;
                    
                    for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
                        accum += buffer[i];
                        count++;
                    }
                    
                    result[offsetResult] = accum / count;
                    offsetResult++;
                    offsetBuffer = nextOffsetBuffer;
                }
                
                return result;
            }
            
            convertToPCM16(float32Array) {
                const buffer = new ArrayBuffer(float32Array.length * 2);
                const view = new DataView(buffer);
                
                for (let i = 0; i < float32Array.length; i++) {
                    const sample = Math.max(-1, Math.min(1, float32Array[i]));
                    view.setInt16(i * 2, sample * 0x7FFF, true);
                }
                
                return buffer;
            }
            
            resetStats() {
                this.startTime = null;
                this.audioBytes = 0;
                this.wordCount = 0;
                this.totalTokens = 0;
                this.totalCost = 0;
                this.tokenUsage = {
                    input: 0,
                    output: 0,
                    inputText: 0,
                    inputAudio: 0,
                    outputText: 0,
                    outputAudio: 0
                };
                // Reset displays
                this.tokensEl.textContent = '0';
                this.costEl.textContent = '$0.0000';
            }
            
            updateTokenUsage(usage) {
                if (!usage) return;
                
                const inputTokens = usage.inputTokenCount || 0;
                const outputTokens = usage.outputTokenCount || 0;
                const totalTokens = usage.totalTokenCount || 0;
                
                // Update cumulative usage
                this.tokenUsage.input += inputTokens;
                this.tokenUsage.output += outputTokens;
                this.totalTokens += totalTokens;
                
                // Process modality breakdown for accurate pricing
                const promptDetails = usage.promptTokensDetails || [];
                const responseDetails = usage.responseTokensDetails || [];
                
                // Update modality-specific token counts from this turn
                promptDetails.forEach(detail => {
                    if (detail.modality === 'TEXT') {
                        this.tokenUsage.inputText += detail.tokenCount;
                    } else if (detail.modality === 'AUDIO') {
                        this.tokenUsage.inputAudio += detail.tokenCount;
                    }
                });
                
                responseDetails.forEach(detail => {
                    if (detail.modality === 'TEXT') {
                        this.tokenUsage.outputText += detail.tokenCount;
                    } else if (detail.modality === 'AUDIO') {
                        this.tokenUsage.outputAudio += detail.tokenCount;
                    }
                });
                
                // Calculate cost based on modality-specific pricing
                const pricing = GEMINI_PRICING['gemini-live-2.5-flash-preview'];
                const inputTextCost = (this.tokenUsage.inputText / 1000) * pricing.inputText;
                const inputAudioCost = (this.tokenUsage.inputAudio / 1000) * pricing.inputAudio;
                const outputTextCost = (this.tokenUsage.outputText / 1000) * pricing.outputText;
                const outputAudioCost = (this.tokenUsage.outputAudio / 1000) * pricing.outputAudio;
                
                this.totalCost = inputTextCost + inputAudioCost + outputTextCost + outputAudioCost;
                
                // Update UI
                this.tokensEl.textContent = this.totalTokens.toLocaleString();
                this.costEl.textContent = `$${this.totalCost.toFixed(4)}`;
                
                // Enhanced logging with modality breakdown
                let detailsLog = {
                    turn: { 
                        input: inputTokens, 
                        output: outputTokens, 
                        total: totalTokens,
                        promptDetails: promptDetails,
                        responseDetails: responseDetails
                    },
                    cumulative: { 
                        input: this.tokenUsage.input, 
                        output: this.tokenUsage.output, 
                        total: this.totalTokens,
                        breakdown: {
                            inputText: this.tokenUsage.inputText,
                            inputAudio: this.tokenUsage.inputAudio,
                            outputText: this.tokenUsage.outputText,
                            outputAudio: this.tokenUsage.outputAudio
                        }
                    },
                    cost: {
                        total: this.totalCost,
                        breakdown: {
                            inputText: inputTextCost,
                            inputAudio: inputAudioCost,
                            outputText: outputTextCost,
                            outputAudio: outputAudioCost
                        }
                    }
                };
                
                console.log('Token usage update:', detailsLog);
            }
            
            updateStats() {
                if (!this.isStreaming || !this.startTime) return;
                
                const duration = (Date.now() - this.startTime) / 1000;
                const minutes = Math.floor(duration / 60);
                const seconds = Math.floor(duration % 60);
                
                // Update duration
                this.durationEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                // Update audio data
                this.audioDataEl.textContent = `${Math.round(this.audioBytes / 1024)} KB`;
                
                // Update word count
                this.wordCountEl.textContent = this.wordCount.toString();
                
                // Cost is now updated via token usage, not time-based estimates
            }
        }
        
        // Initialize client
        const client = new GeminiLiveClient();
    </script>
</body>
</html>